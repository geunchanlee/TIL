# 동적 메모리

- 정적(static) 메모리 할당

프로그램 시작 전에 미리 정해진 크기의 메모리 할당

<br>

- 동적 메모리 할당

실행 도중에 동적으로 메로리를 할당받음

더 큰 입력이 들어오면 더 많이 할당, 낭비되면 더 적게 할당

필요한 만큼만 할당받아 메모리를 효율적으로 사용가능

실제 상용 프로그램에서는 정적 메모리 할당은 거의 하지 않는다.

malloc()계열의 라이브러리 함수 사용


## 동적 할당 기능

### malloc(), free()

stdlib.h 헤더 파일에 정의됨

- 함수원형: void *malloc(size_t size)

malloc 하면 heap영역에 주소 할당 실패시 NULL을 반환하므로 꼭 체크할것

void* 는 무엇을 가리키는지 상관없는 그냥 주소값

- 함수원형: void free(void *ptr)

사용한 메모리 영역 반납

### 구조체 동적 생성


### realloc()

더 많은 공간, 더 적은 공간이 필요하다면?

할당된 메모리 블록의 크기를 변경한다

- 함수원형: void* realloc(void* memblock, size_t size)

stdlib.h 헤더 파일에 정의됨

__memblock__: 기존에 할당받았던 메모리 블록 주소

__size__: 새로 할당할 크기

할당 성공시 할당된 메모리 블럭의 첫바이트의 주소 반환, 할당된 메모리에 담고자 하는 자료형의 주소로 타입캐스팅 하기

실패시 NULL반환

단위를 하나씩 늘리면 오버헤드가 발생할 수 있기 때문에 어느정도 단위(1024, 128)를 잡아 늘림

### memset()

할당받은 메모리를 초기화 malloc, realloc으로 메모리 공간을 할당받으면 쓰레기 값이 들어가있다. 그렇기 때문에 이를 곧바로 쓰지 말고 비운 뒤에 사용해야한다.

stdlib.h 헤더파일에 정의됨

함수원형: void* memset(void* ptr, int value, size_t num)

__ptr__: 할당된 메모리블럭 주소

__value__: 메모리 채울 값 (초기화니까 보통 0)

__num__: 채울 바이트의 수

ptr이 반환됨

- memset 예시
 ```c
 p = (int *)malloc(sizeof(int)*10);
 
 memset(p,0,10);

 ```
 
### calloc()

malloc + memset

malloc과 달리 메모리 할당한 후 0으로 초기화한다

함수원형: void * calloc(size_t n, size_t size)

__n__: 할당할 원소의 수

__size__: 할당할 원소의 크기


## 동적 할당의 대표적 오류들

동적 할당은 힙 메모리를 직접적으로 건드릴 수 있는 강력한 기능이다.

자바나 파이썬같은 언어는 C, C++과 다르게 메모리에 직접적 접근이 불가능하다.

메모리를 직접 관리한다는것은 현실적 어려움이 있는데 살펴보자

1. **메모리 할당이 성공했는지 체크하지 않는 경우**
    
    - 메모리 할당이 실패해서 NULL포인터를 반환받았을 때 이를 무시하고 사용하려고 하면 에러 발생
    
    - NULL포인터 체크를 해야한다는 원칙을 지키자!

2. **메모리 누수(leak)**
    
    - free로 메모리 반환을 해야하는데 반납을 하지 않고 할당만 하게 되면 메모리가 가득 차 할당받을 수 없게 됨

    - 간단히 반환하면 될 것 같은데 왜 발생할까? 
    
        프로그램이 실행되면서 수많은 분기가 일어나기 때문에 모든 경우를 추적하기 힘들다.

        많은 경우를 테스트하는게 중요

    - Rust, Go 같은 언어에서 문법을 C보다 엄격하게 해 오류가 적은 프로그래밍을 할 수 있게 함

3. **논리적 오류**

    - 이미 free한 메모리 다시 참조하려고 할 경우(dangling pointer)

    - malloc 하지 않은 메모리 참조하려고 할 경우(wild pointer)

    - free를 두 번 하려고 할 경우(double free)

