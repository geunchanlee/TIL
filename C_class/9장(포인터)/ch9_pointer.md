### 23.11.1 포인터 수업 1

# 포인터 (pointer)

- 포인터 = 주소!

주소를 가지고 있는 변수

메모리 -> 바이트 단위로 구성 

> 1byte = 8bit

바이트 단위로 주소가 부여된다<br>

주소를 왜 알아야 할까?

메모리의 특정한 번지에 쓰고싶은 값을 직접 쓰고 불러올 수 있다

**왜?** -> 빠르다, 효율적인 메모리 사용이 가능하다

운영체제, 게임 등 빠른속도가 필요할 때 C를 사용

고급 언어에서 유일하게 메모리에 직접 접근할 수 있는 언어이기에 C를 사용한다

pointer를 사용하지 않을 것이면 C를 쓸 필요가 없다

---

### 변수와 메모리

변수 크기에 따라서 차지하는 메모리 공간이 달라진다

메모리 = 데이터 영역, 스택 영역, 힙 영역으로 나눠진다

변수를 선언할 때 주소를 os에서 정한다

앞으로는 변수의 주소를 고려해야 한다

주소를 알기 위해선 &연산자를 사용

> 변수 i 의 주소: **&i**

### 포인터 변수

포인터: 주소를 가지고 있는 변수

~~~c
int* p;
~~~

(int* p, int *p, int * p 세 방식 다 써도 된다)

int * 까지가 type

p 가 변수이름

int = 이 주소에 정수 변수가 담겨져 있다

64비트 cpu에서 포인터의 크기는 8바이트

int *pi, float *pf, double *pd, char *pc

이 4가지 포인터의 크기는 다 같다

이 주소가 가리키는 곳에 있는 type이 다른 것

<br>

포인터를 초기화하지 않으면 쓰레기 값이 들어간다

<br>

### 간접 참조 연산자 *

포인터가 가리키는 값을 가져오는 연산자

~~~c
int i=10;
int *p;
p =&i;
printf("%d",*p);
~~~

2 번째 줄의 *와 4 번째 줄의 *는 다르다

4번째 포인터(*)변수는 p라는 포인터 변수가 가리키는 곳을 말한다

참조 연산자로의 포인터를 쓸 때는 타입이 안 나온다

---

<br>

**포인터 연산자에선 2가지의 연산자를 기억하자**

1. 주소 연산자(&)

2. 간접 참조 연산자(*)

<br>

## 포인터 연산

포인터 연산은 타입의 크기만큼 더하고 뺀다

char type을 ++ 하면 1, int type ++하면 4 가 늘어난다

### 간접 참조 연산자와 증감 연산자

v = *p++; 
> p가 가리키는 위치에서 값을 v에 가져온 후에 p증가

v = (*p)++;
> p가 가리키는 값을 v에 대입한 후에 가리키는 값을 증가

v = *++p
> p를 증가시킨 후에 p가 가리키는 값을 v에 대입

v = ++*p
> p가 가리키는 값을 가져온 후에 그 값을 증가하여 v에 대입

4가지 정도 경우에 어떻게 가리키는 값이 달라지는지 알아두기

<br>

## 함수와 포인터

함수 호출시 인수의 전달 방법

**1. 값에 의한 호출 (call-by-value)**

> 인수의 값이 매개변수로 복사된다

기본적으로 사용하는 방법

간편하지만 데이터가 크면 오버헤드 발생

<br>

**2. 참조에 의한 호출 (call-by-reference)**

> 인수의 주소가 매개변수로 복사된다

값을 넘겨주는것이 아니라 값이 들어있는 곳의 **주소**를 넘겨준다

효과 1: 인자가 매우 커도 주소만 넘겨주기 때문에 오버헤드가 줄어든다

효과 2: 함수 안에서만 유효한 지역변수를 다른 함수에서도 접근가능하게 한다 (주소를 넘겨주니까) -> 함수의 리턴값이 여러개가 되는 결과를 일으킬 수 있다

원본 호출이라고도 부른다

<br>


### 포인터 사용시 주의점

1. 초기화되지 않은 포인터는 사용하면 안된다.

초기화 전엔 쓰레기 값이 들어있는데 이 주소가 중요한 구역일 수 있기 때문

포인터가 아무것도 가리키지 않을 때는 NULL로 초기화하자

~~~c
// 위험한 코드 (주소 p가 os영역이라면?)
int* p;
*p = 100;

// NULL로 초기화하자!
int* p = NULL;
if(p) *p = 100; // p가 NULL이면 실행되지 않는다

~~~

<br>

2. 포인터의 타입과 변수의 타입은 일치해야 한다.

double형 포인터에 int형 변수 주소를 대입하면 안됨

<br>

## 배열과 포인터

배열과 포인터는 아주 밀접한 관계를 가지고 있다.

**배열의 이름 = 포인터**

포인터도 배열과 똑같이 사용가능하다

배열 이름에 다른 변수 주소 대입 불가

<br>

---

### 11.2 포인터 수업 2

함수가 포인터를 반환하는 경우

함수가 종료되면 result가 들어있던 주소가 쓰레기 값, 다른 프로그램의 점유가 될 수 있다

### 함수 포인터

함수를 가리키는 포인터

문법: 반환형 (*함수포인터이름)(매개변수);

> **int (*pf)(int, int);**

리턴 타입, 매개변수 타입이 동일한 함수만 지칭할 수 있다

### 이중 포인터

포인터를 가리키는 포인터

~~~c
int a = 3;
int* p1;    // p1은 int를 가리키는 주소
int** p2;   //p2는 int*를 가리키는 주소
            //p2 = int*를 가리키는 주소를 카리키는 주소
~~~

이중 포인터의 필요성 1

local변수의 값을 바꾸기 위해서 call-by-reference를 사용

함수 외부에서 선언된 **포인터변수** 자체를 조작하기 위해서는 이중 포인터를 사용해야 할 필요가 있다. = 주소를 바꾸기 위해서 이중포인터를 사용한다

이중 포인터의 필요성2

동적 할당된 다차원 배열의 주소값을 가지기 위해, 동적 할당된 배열을 함수의 인자로 주기 위해서..