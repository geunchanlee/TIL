# TIL 26/01/19 - Modern JavaScript 2

[Modern JavaScript 1](https://github.com/geunchanlee/TIL/blob/main/devCourse/TIL_260116.md)

<br>

## 스프레드 구문(Spread syntax)

[MDN Web Docs - **Spread syntax**](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

배열이나 객체에 이용할 수 있는 표기법

배열이 전개되어 내부 요소를 순차적으로 전개 가능

`...arr` 처럼 하면 배열 내부 요소를 순차적으로 보여준다

파이썬의 `*list`쓰던 것과 유사하다 

**스프레드 구문 사용하기**

```jsx
const arr1 = [0, 1, 2, 3]; // 배열 선언

const arr2 = arr1.slice(); // 배열 복사하는 법
console.log(arr2);
>>> [ 0, 1, 2, 3 ]

const arr3 = [...arr1]; // 스프레드 구문을 사용해서도 복사 가능
console.log(arr3);
>>> [ 0, 1, 2, 3 ]

const [num1, num2, ...arr4] = arr1; // 나머지 값 넣는 스프레드 구문
console.log(num1, num2, arr4);
>>> 0 1 [ 2, 3 ] // num1, num2 할당하고 남은 요소들 할당된 모습

```

스프레드구문을 사용하면 매개변수에 하나씩 채워서 함수를 사용할 수 있다.

```jsx
function myFunction(x, y, z) {}
var args = [0, 1, 2];
myFunction(...args);
```

x, y, z에 0, 1, 2 가 들어가게 된다.

### = 를 이용한 복사

배열이나 객체 등의 `Object type` 변수를 등호로 복사하면 참조값(변수 실제 위치 값)도 함께 상속되어 예상하지 못한 동작 발생할 가능성이 있다.

참조 복사, 얕은 복사(*Reference copy, shallow copy*), 값 복사(*deep copy*)

```jsx
const arr1 = [10, 20];
const arr2 = arr1; // shallow copy
const arr3 = [...arr1]; // deep copy

arr1[0] = 100;

console.log(arr1);
console.log(arr2);
console.log(arr3);

>>> [ 100, 20 ]
>>> [ 100, 20 ] // arr2도 arr1과 같은 곳을 참조한다.
>>> [ 10, 20 ]
```

참조하고 있는 주소를 복사했기 때문에 `arr1`만을 수정했어도 `arr2`까지 바뀐것을 볼 수 있다.

`=`를 사용한다면 자바스크립트에선 얕은 복사가 수행되어 원본객체와 같은 참조를 공유한다.

스프레드 연산자를 이용해 깊은복사를 실행하면 바뀐 arr1과 별도의 배열이 생성된다.

<br>

## 객체 생략 표기법

shorthand

객체의 속성명과 설정할 변수명이 같으면 생략 가능

```jsx
const myName = "chan";
const age = "30";

const user = {
    myName,
    age,
};

console.log(user);

>>> { myName: 'chan', age: '30' }
```

const user에서 `name: name`, `age: age` 처럼 사용하지 않아도 잘 표시된다.

<br>

## map

배열을 순회할 때 기존엔 for문을 사용했다.

모던 자바스크립트에선 map 함수를 이용한 방법도 있다.

```jsx
const lang = ['java', 'python', 'c', 'javascript', 'c++'];
const arr = lang.map((lang) => {
    return lang;
});

console.log(arr);
>>> [ 'java', 'python', 'c', 'javascript', 'c++' ]
```

map = 사용자 기능 정의 함수

map에 화살표함수로 lang배열을 반환하는 기능을 담아 사용한 것

### map - index

map 함수의 두 번째 위치에 인수를 넣으면 0부터 index 정보가 저장된다.

```jsx
const lang = ['java', 'python', 'c', 'javascript'];
const arr = lang.map((lang, index) => {
    console.log(`${index}. ${lang}`);
});

>>> 0. java
>>> 1. python
>>> 2. c
>>> 3. javascript
```

lang 배열의 요소 값을 수정해 새로운 배열을 만들 수 있다.

```jsx
const newLang = lang.map((lang) => {
    if (lang === 'c') {
        return `${lang}++`;
    } else {
        return lang;
    }
});

console.log(newLang);

>>> [ 'java', 'python', 'c++', 'javascript' ]
```

<br>

## filter

map과 비슷하지만 return 뒤에 조건식 입력해 일치하는 것만 반환한다.

```jsx
const langs = ['java', 'python', 'c', 'javascript', 'go', 'rust', 'kotlin'];
const result = langs.filter((lang) => lang.length < 5);
console.log(result);

>>> [ 'java', 'c', 'go', 'rust' ]
```

`langs` 배열에서 길이가 5미만인 요소들만 뽑아 반환한 result배열을 만든다.

<br> 

## 최신 문법 내용(ES2020 ~ ES2022)

### Optional Chaining (`?.`)

[MDN Web Docs - **Optional chaining**](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Optional_chaining)

객체 속성과 배열 요소에 접근할 때 중간 값이 null, undefined인 경우 에러 없이 `undefined` 반환한다.

```jsx
const pc = {
    cpu: "AMD",
    gpu: "Nvidia",
    ram: null,
}

console.log(pc.cpu);
>>> AMD

console.log(pc.ram);
>>> null

console.log(pc.case); // 존재하지 않는 속성 접근 = undefined
>>> undefined

console.log(pc.case.color); // null, undefined의 속성에 접근하면 오류 발생
>>> TypeError: Cannot read properties of undefined (reading 'color')

console.log(pc.case?.color); // 옵셔널 체이닝 사용해 오류 발생 x
>>> undefined
```
존재하는 pc 객체의 존재하지 않는 속성에 접근하는 것 까지는 undefined가 발생하고 오류가 일어나지 않지만 존재하지 않는 객체의 속성에 접근하려고 하니 오류가 발생한다. 옵셔널 체이닝 `.?` 을 사용하면 오류 발생 없이 종료할 수 있다.


### Nullish Coalescing Operator (`??`)

[MDN Web Docs - **Nullish coalescing assignment**](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_assignment)

좌측 값이 nullish(*null or undefined*)일 때 오른쪽 피연산자를 왼쪽에 할당

nullish가 아니라면 할당 수행되지 않음

```jsx
let x;
console.log(x ?? 'nullish');

>>> nullish // ??가 없었다면 undefined

x ??= 10;
console.log(x)

>>> 10 // 아래의 축약 연산자 사용 결과
```

### Optional Catch Binding

`try ... catch` 문에서 에러 객체를 생략 가능

### 배열 메소드 개선

`Array.prototype.includes()`

요소 존재 여부를 간단히 확인 가능

### Logical Assignment Operators (`&&=`, `||=`, `??=`)

기존 연산자와 대입을 결합해 축약한 문법