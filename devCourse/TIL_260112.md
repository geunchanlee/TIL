# TIL260112~13 - JavaScript

오늘 배운 내용 간략하게 기억

## 자바스크립트

### 변수 선언

var 선언

→ 호이스팅 = var로 선언된 변수들 프로그램 동작 전에 먼저 다 읽어온다.

→ let이나 const로 선언 시 호이스팅이 되지만 var와는 다른 방식으로 작동하는데, 변수 선언만 해두고 초기화는 코드 실행 과정에서 변수 선언문을 만났을 때 수행하는 방식으로 실행되기 때문에 변수 선언 전에 참조하려고 하면 오류가 발생한다.

규칙

1. 변수 이름에 사용가능: 알파벳, 숫자, 밑줄, 달러기호

2. 첫 글자 숫자 사용 불가

3. 예약어 사용 불가

4. 데이터 타입 지정하지 않음

5. 변수에 값 저장되는 순간 타입 결정

### 특수한 표현

undefined ⇒ 변수 정의되었지만 값이 할당되지 않음

null ⇒ 값이 비어 있을 경우 사용할 수 있는 표현 → null을 직접 할당해야 함

`var name = null;` 

### 주석

```jsx
// 한 줄 주석

/*  
* 여러 줄 주석
* ...주석주석
*/
```

---

### 화면출력 방법

`console.log` 

`document.write`

`document.write(result, “<br>”)`

---

### 연산자

    +=, -=, *=, %=

    var num1 = 13;

    num ++; (증감연산자)

### 문자 결합

더하기에 문자형 데이터 포함 시 자동으로 문자형 데이터로 형 변환해 결합됨

### 비교 연산

`==`: 타입은 비교하지 않음

`===`: 비교 대상 간 타입까지 일치해야 true

|| or, && and, !: not 

---

<br>

# 제어문

## 조건문

### if

조건식의 값이 true인지 false인지에 따라 자바스크립트 코드를 제어

```jsx
if( 조건식 ) {

	자바스크립트 코드;

} else if {

코드 2;

} else {

code 3

}
```

### switch-case

switch(parameter)에 들어온 값을 비교해서 조건문 실행

```jsx
switch(x) {
	case x: ...;
	break;
	case y: ...;
	break;
	default: alert(”alert”);
	location.reload(); // 새로고침
}
```

## 반복문

### for

```jsx
for ( 반복 값 초기화; 조건식; 증감식 ) {
	반복문장
}
```

중첩 for 가능

- for 안에 for 사용한다

### while

```jsx
var i = 0; // 반복 컨트롤 변수

while ( 반복 진행 여부 체크 ) {
	반복 문장
	i++; // 반복 제어 증감식
}
```

무한반복에 빠지는 것 주의하기 반복문을 break하거나 조건에 대해 생각하자

**실습예제**

```jsx
// while을 이용해 1부터 100 사이 중 3의 배수만 출력
let i = 1;
while (i < 101) {
    if (i % 3 === 0) {
        console.log(i);
    }
    i += 1;
}
```

```jsx
// while을 이용해 구구단 3단 출력
let j = 1;
while (j < 10) {
    console.log("3 * "+ j +" = "+ j*3);
    j += 1;
}
```

---
<br>

## 함수

작업 단위 정하고 일부 분리시켜 관리

```jsx
function 함수() {
	...
	...
}

함수();
함수();
함수();

```

기능 단위로 함수 정의해두기 -> 코드의 수정을 편하게 한다


### 기본 함수 정의

```jsx
// 가장 기본적인 함수 선언 방법
function 함수이름(x) {
	return x*x;
}

// 함수의 기능만 정의하고 변수에 할당 
var 변수명 = function(x){
	return x*x;
}; // 끝에 세미콜론 필요 

var 변수명 = new Function (”x”, “return x*x”);

var 변수명 = x => x*x; // 화살표 함수 표현

//함수호출
함수이름();
```

함수이름은 기능을 직관적으로 알아볼 수 있게 동사로 작성하자

기본형태를 머리에 담아두기 

**변수영역**

다른 언어에서 변수 영역(java)

함수 안에 변수를 정의하면 ⇒ 중괄호 기준으로 살아있다

**Javascript**에서 변수의 영역

자바스크립트에서는 `function` 기반 영역 사용

`function` 내부에서 선언된 변수는 `function`의 모든 영역에서 사용 가능하다.

### 전역 변수, 지역 변수

전역변수의 유효범위는 전체 프로그램, 지역변수는 선언된 함수 안에서만 유효하다.

따라서 함수 바깥에서 지역변수를 읽으려고 시도하면 참조 오류가 발생한다.

### 함수 종류

**매개변수가 있는 함수**

- 함수를 호출할 때 전달하고자 하는 값을 입력하여 호출

```jsx
function 함수이름( 매개변수1, 매개변수2, ... ) {
	자바스크립트 코드;
}
```

```jsx
function myFunc(name, area) {
	document.write("Hi, my name is " + name, "<br>");
	document.write("I live in " + area, "<br><br>");
}

myFunc("근찬", "인천");
```

- 자바스크립트에선 매개변수의 개수가 맞지 않아도 함수가 정상적으로 실행됨
    - 매개변수가 더 많거나 적어도 오류가 발생하지 않음!

숫자 더할 때 매개변수보다 적게 넣으면 undefined로 처리되어 NAN 값이 나온다

함수 내부에 undefined와 같을 때를 처리하는 문구를 넣어두면 방지 가능

return은 함수에서 결과값을 반환할 때 사용

`return` 이 실행되면 코드 종료된다.

### **중첩 함수(Nested Function)**

자바스크립트는 중첩함수를 사용할 수 있다.

- 특정 함수 내부에 선언된 함수. 지역 함수, 내부 함수라고 부르기도 한다.

```jsx
funtion getCalcNumbers (num1, num2) {
	var result = calcPlus (num1, num2);
	
	function calcPlus ( num1, num2) {
		return num1 + num2;
	}
	
	return result;
}
```

내부에서 정의된 함수는 밖에서 알 수 없다.

`calcPlus();` 처럼 호출할 수 없다

- 함수 안의 if, while문 등의 안에는 중첩함수를 작성할 수 없다.
    - 내부함수 안에서도 밖을 바라볼 수 없 기 때문
- 자바스크립트에 접근제한자가 없어서 기능을 숨기기 위해 중첩함수를 사용한다.

### 재귀 함수(Recursive Call Function)

- 함수 정의문 내에서 작성한 코드로 함수를 다시 호출하는 것

```jsx
var num = 0;
function testFunc() {
	num++;
	document.write(num, "<br>");
	if(num == 10) return;
	
	testFunc();
}
```

재귀를 사용하면 공간복잡도가 증가한다. 재귀로 간단히 문제를 해결할 수 있을 때만 사용

### 콜백 함수(Callback Function)

- 다른 함수에 인수로 넘겨지는 함수

```jsx
function getCalcNumbers ( callback ) {
	var result = callback (10, 60);
	return result;
}

// Callback Function
var callbackFunction = function ( num1, num2 ) {
	return num1 + num2;
}

var result = getCalcNumbers ( callbackFunction );
```

매개변수로 값만 넘기지 않고 기능도 넘길 수 있다.

함수 안에서 외부로부터 전달받은 함수를 실행시킬 수 있다.

매개변수로 넘어온 함수의 기능을 받은 함수 안에서 필요할 때 실행시킬 수 있다.

### 함수를 리턴하는 함수

- 중첩 함수와 유사하지만 함수를 리턴하는 점이 다름

```jsx
function getCalcNumbers ( num1, num2 ) {
	return function () {
		return num1 + num2;
	}
}

var calc = getCalcNumbers(10, 80); // 리턴된 함수 기능을 calc에 할당
var result = calc(); // 리턴된 함수를 실행
```

함수를 호출함과 동시에 다른 함수로 바꿀 수 있다.

자기 자신을 재정의하는 함수 구현 

### 클로저(closure)

- 자기 자신이 정의된 환경에서 함수 안에 있는 자유 변수의 식별자 결정을 실행
    - Private한 변수나 함수를 가릴 때 사용함
    - 클로저는 캡슐화된 객체이다

```jsx
function counter() {
	var count = 0;
	return function () {
		return ++count;
	}
}

var count = counter();
var result = count();
>>> 1

result = count();
>>> 2

result = count();
>>> 3
```

counter 함수 내부의 count 변수를 함수가 계속 사용해서 사라지지 않게 하는 상태

함수 == 객체

---

## 객체 (Object)

객체 기능 구현하는 메소드와 속성 있음

**객체의 종류**

- 내장객체
- 브라우저 객체 모델(Browser Object Model)
    - 브라우저를 컨트롤할 수 있는 객체
- 문서 객체 모델(Document Object Model) `DOM`
    - HTML문서 구조를 말함
    - 최상위 <html> 아래 <head>, <body>…
    - Javascript의 DOM이 IE8이하 버전에서 호환성 문제가 있음
    - jQuery DOM을 사용해 해결

### 내장객체 (**built-in objects)**

내장객체 생성하기

참조변수(인스턴스 이름) = new 생성 함수()

날짜 정보 객체

var 참조 변수명 = new Date();

크리스마스까지 남은 날짜정보 객체 해보기

배열객체도 해보기

### 배열

- 여러 개의 데이터를 하나의 저장소에 저장하기 위해 배열 객체 생성

```jsx
// 배열을 생성하는 3가지 방법

var scores = [100, 90, 100];

var scores = new Array[100,90,100];

var scores = new Array();
scores[0] = 100;
scores[1] = 90;
scores[2] = 100;
```

for문 인덱스로 접근할 수도 있고, 배열 자체를 for문으로 순환할 수 있다.

배열 객체 메소드

join(문자) 문자 기준으로 배열 요소 1개의 문자형 데이터로 반환

contcat(), length, pop(), push()

shift() → 첫 번째 인덱스 데이터 삭제

unshift() → 배열 가장 앞 인덱스에 새 데이터 삽입

### 문자열

문자열 객체 생성

```jsx
var 참조 변수명 = new String(문자형 데이터);
var 참조 변수명 = 문자형 데이터; // 보편적으로 많이 쓰는 방법
```

문자는 배열처럼 들어간다 

문자열 객체에서 사용되는 메소드들이 있음

`chatAt(index)` 문자열 인덱스 번호 해당 문자 반환

`indexOf(찾을 문자)` 문자열 왼쪽부터 먼저 일치하는 문자의 인덱스 번호 반환

`lastIndexOf(찾을문자)` 문자열 오른쪽부터 먼저 일치하는 문자의 인덱스 번호 반환

`substr(a, 문자개수)` a인덱스부터 지정한 문자 개수만큼 문자열 반환 

`split(문자)` 문자 데이터를 지정문자 기준으로 나누어 배열에 저장해 반환

`toLowerCase(), toUpperCase()` 영문 소, 대문자로 변환

`Length` 문자열의 문자 개수 반환

`concat(새로운 문자)` 문자열에 새로운 문자열 결합 (`+` 도 같은 기능)

`charCodeAt(index)` index에 해당 문자의 아스키코드 값 반환

`trim()` 앞 또는 뒤 공백 문자열 삭제

### 브라우저 객체

브라우저에 내장된 객체. window는 브라우저 객체의 최상위 객체이며, 하위에 다양한 객체 포함

- open(): 지정한 URL페이지를 새 브라우저 창에 표시

`window.open(”URL”, “새 창 이름”, “새 창 옵션”);`

- alert()

`alert(전달하고자 하는 메시지);`

- confirm()

`confirm(질문);`

---


### 객체 리터럴 (Object Literal)

자바스크립트에서는 원시타입을 제외한 모든 값이 객체

자바스크립트에서의 객체 생성 방법 → 객체 리터럴 `{}`

```jsx
let object = {}; // 객체 생성

object.name = "LEE Geunchan";
object.job = "None";
object.hello = function(){
    console.log("안녕하세요");
};

console.log(object.name);
console.log(object.job);
object.hello();

>>> LEE Geunchan
>>> None
>>> 안녕하세요
```

object 변수를 객체화해서 생성하고

객체에 name, job필드를 추가

## 생성자 (Constructor)

생성자를 사용하면 이름 같은 메소드와 프로퍼티를 가진 객체 여러 개를 생성 가능

`new` 키워드를 이용해 객체를 만들어낼 수 있다.

```jsx
function Car() {
	this.carBrand = "Hyundai";
	this.carName = "Casper";
}

let car = new Car();
console.log(car.carBrand);

>>> Hyundai
```

### **매개변수가 있는 생성자**

```jsx
function Car( carBrand, carName) {
	this.carBrand = carBrand;
	this.carName = carName;
}

let car = new Car("Hyundai", "Casper");
console.log(car.carBrand);
console.log(car.carName);
console.dir(car);

>>> Hyundai
>>> Casper
>>> Car { carBrand: 'Hyundai', carName: 'Casper' }
```

### 메서드를 가진 객체를 생성하는 생성자

```jsx
function Car(carBrand, carName) {
	this.carBrand = carBrand;
	this.carName = carName;
  this.showMyCar = function() {
    console.log(this.carBrand);
    console.log(this.carName);
  };  
}

let car = new Car("Hyundai", "Casper");
car.showMyCar();

>>> Hyundai
>>> Casper
```

---