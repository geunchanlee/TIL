# TIL_26/01/30 - DOM 삭제 vs display: none


프로그래머스 백엔드 교육과정의 시작이었던 한 달간의 프론트엔드 교육, 프로젝트가 종료되었다! 나름 열심히 참여한 것 같다.

프로젝트 이후 중간 평가로 치뤄진 자바스크립트 테스트에서 문제에서 주어진 내용을 구현하는 미션이 있었다. 구현 미션 수행 중 시행착오를 겪은 부분에 대해 학습했다.

### 구현 요구

- 페이지에서 이벤트가 일어나면 특정 요소를 필터링해서 보여줘야 함
    - 검색, 조건설정(필터링) 등의 예시를 들 수 있을 듯

처음엔 페이지에서 표시되지 말아야 하는 요소의 css 속성 중 display: none 속성을 사용해 잘 사라지도록 구현했다.

내가 사용자 입장에서 해당 기능을 작동시켜보니 아무 불편함 없이 잘 작동되는 것을 확인할 수 있었다. 하지만 코드 채점 중 해당 항목에 대해 **실패** 처리가 되는 모습을 확인할 수 있었다. 

처음엔 ***왜 ???*** 하고 놀라서 오류인 줄 알고 테스트 브라우저도 껐다 켜 보고 프로젝트 npm start도 다시 해보고 별 이상한 짓을 했다..

그러다가 개발자 도구를 열어서 필터링이 잘 되는건가 들여다봤는데, 내가 숨길 속성에 display: none이 잘 들어간 모습을 보니 불현듯 이 속성이 붙은 div 박스 자체가 없어져야 할지도 모른다는 생각이 들었고 해당 기능을 구현해 테스트하니 통과할 수 있었다.

마무리하고 자연스럽게 든 생각은 아니 `display: none`이나 `DOM요소 삭제`나 내 눈엔 똑같은데 이걸 왜 이렇게 채점해!! 하고 화가 났다.

? 근데 이 둘이 진짜 똑같을 리가 없잖아…. 해당 내용을 찾아보게 됬다.

### 브라우저 렌더링 파이프라인

우선 브라우저가 화면을 그리는 방식을 아주 일부만 이해해보자. 

<p align="center">
  <img src="https://github.com/user-attachments/assets/dd1fc22a-b9ad-4741-95b1-6ff61b27e8d3" /><br>
  <sub>출처: <a href="링크">https://medium.com/@johnnygerard/deep-dive-into-the-browsers-rendering-pipeline-4c88c91f7bdc</a></sub>
</p>



브라우저가 화면을 그릴 때 파서가 CSS 스타일시트를 **CSS 객체 모델(CSSOM)**이라는 트리 구조로 변환하고 HTML 문서는 **문서 객체 모델(DOM)**트리로 변환한다. 이 둘이 합쳐져서 **렌더 트리(Render Tree)**가 생성된다.

**Render Tree =** `DOM` **+** `CSSOM`

렌더 트리를 생성할 때 각 요소의 선택자 우선순위, 캐스케이딩, 상속 규칙을 적용해 최종 스타일을 계산한다.

그리고 `display: none` 이 적용된 요소와 그 자식 요소는 렌더 트리에서 완전히 제외된다. 

하지만 렌더 트리에서 제거되어도 **DOM트리**에는 남아있다. → 파싱 과정은 거쳐야 한다! → 메모리를 점유하게 된다!! → 렌더링 시 자원을 사용한다!!!

`display:  none` 그림에서 layout, paint 단계의 자원은 아끼지만 그 전 DOM트리 생성과 스타일 계산 단계 자원은 사용하게 된다. 

DOM트리에서 아예 제거하게 된다면 이런 일이 발생하지 않게 된다. 지금 내 상황에선 기껏해야 열 몇개의 DOM요소를 다뤘기 때문에 크게 와닿진 않았다. 하지만 만약에 display: none으로 가려진 요소가 **수천 개**, **수만 개**라면? 보이지도 않는 수천 개의 요소를 DOM에 갖고있기보단 아예 제거해버리는게 최적화에 좋을 것이다.

DOM에서 제거하게 된다면 다시 사용할 때 새로 생성해서 추가해야 한다. 만약 내가 만들어야 될 기능이 탭, 모달 같은 자주 나타났다 사라져야 하는 UI라면 `display: none`을 사용하는게 더 좋을 것이다.

### 번외

`display: none`, `visibility: hidden`, `opacity: 0` 은 뭐가 다를까?

위에서 브라우저 렌더링 파이프라인을 살펴봤으니 더 쉽게 이해할 수 있다.

`display: none`은 앞서 말했듯이 렌더트리에 존재하지 않는다. `visibility: hidden`과 `opacity: 0`은 렌더트리에 존재한다. 

**Reflow**(레이아웃 재 계산), **Repaint**(다시 그리기)에서 어떤 차이가 발생하는지 볼 수 있다.

1. `display: none` 
    
    렌더 트리에서 제외, 공간 차지 없음. 
    해당 요소는 상태 변경 시 Reflow + Repaint가 모두 일어나 가장 많은 자원을 사용한다.
    
2. `visibility: hidden`
    
    렌더 트리에 포함, 공간 차지함. 
    상태 변경 시 Repaint 발생한다.
    
3. `opacity: 0` 
    
    렌더 트리에 포함, 공간 차지함.
    GPU가속을 사용해 성능상 가장 유리하다.
    

---

### 참고한 글

- [Johnny Gérard - Deep Dive into the Browser's Rendering Pipeline](https://medium.com/@johnnygerard/deep-dive-into-the-browsers-rendering-pipeline-4c88c91f7bdc)
- [MDN Web Docs - 웹페이지를 표시한다는 것: 브라우저는 어떻게 동작하는가](https://developer.mozilla.org/ko/docs/Web/Performance/Guides/How_browsers_work)
