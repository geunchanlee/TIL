# TIL 26/01/16 - Modern JavaScript 1

**모던 자바스크립트**

리액트, 뷰, 앵귤러 등 가상 DOM을 이용하는 라이브러리 혹은 프레임워크를 사용

`npm`, `yarn` 등의 **패키지 관리자** 사용

주로 **ES6** 이후의 표기법 사용

`webpack` 등의 **모듈 핸들러** 사용

`babel` 등의 **트랜스파일러** 사용

**SPA: *Single Page Application***으로 작성


---

### 패키지 관리자

작성된 자바스크립트에서 로딩 순서를 지키지 않으면 에러 발생하거나 로딩된 상수, 변수 사용하는 경우 어디서 로딩된 건지 알기 어려운 문제들 존재

패키지 관리자는 여러가지 패키지들의 관리, 설치, 업그레이드 등을 맡음

- 자바스크립트의 npm, 루비의 gem, 파이썬의 pip 등..

모두 같은 패키지 버전을 사용할 수 있게 해 줌

**npm, yarn의 장점**

- 의존관계를 의식하지 않아도 자동 해결

- 팀 안에서 패키지를 공유하고 버전 통일하기 쉽게 함

- 공개된 패키지를 하나의 명령어로 이용 가능

- 어디서 로딩한지 알기 쉬움

아래 명령어로 패키지 설치

`npm install [패키지명]` `yarn add [패키지명]` 

package.json이 변경되고 패키지 정보가 추가 

npm으로 설치하면 package-lock.json파일, yarn으로 설치하면 yarn.lock 파일이 생성된다.

lock 파일에는 패키지가 내부에서 사용하는 다른 패키지의 버전 정보, 의존 관계가 기록된다.

`npm install` `yarn add`

이 명령어를 실행시 package.json, package-lock.json을 참조해 버전, 의존관계가 해결된 상태로 node_modules폴더를 만들고 그 안에 패키지를 전개한다

### 모듈 핸들러(Module handler)

개발시에는 파일을 나누어 개발하는게 효율적이고 생산성도 높아지지만 프로덕션 환경에서 실행할 때 파일을 나누게 되면 로딩횟수가 늘어나 성능 저하가 일어날 수 있다.

미리 설정파일을 만들고 빌드를 실행하면 모듈핸들러가 파일들을 모은 것이 생성되어 해당 파일을 프로덕션 환경에 반영해 프로그램 실행 가능

- 웹팩(webpack) 모듈 핸들러가 주로 사용됨

### 트랜스파일러(Transpiler)

자바스크립트 표기법을 브라우저에서 실행할 수 있는 형태로 변환해 줌

브라우저는 바닐라 자바스크립트를 실행할 수 있지 모던 자바스크립트를 실행할 수 없다

트랜스파일러는 모던 자바스크립트를 일반적인 바닐라 자바스크립트 형태로 변환해 동작할 수 있게 번역해줌

- 바벨(babel) 트랜스파일러를 주로 사용함

### SPA(Single Page Application)

HTML 파일은 **하나**만 사용, 자바스크립트를 이용해 DOM을 바꿔서 화면 이동을 구현한다

- 사용자 경험이 향상된다

    - 서버에 요청 없이 페이지 이동이 완료되어 화면 표시속도 향상

- 컴포넌트 분리를 쉽게 해 개발 효율이 좋아짐

    - 페이지마다 HTML파일을 준비하는 기존과 달리 리액트 등 모던 자바스크립트로 개발할 땐 화면 각 요소를 컴포넌트로 정의해 재사용 가능

모던 자바스크립트 개발은 SPA를 표준으로 사용

<br>

## Type

`typeof` 연산자로 타입을 확인할 수 있다

### 원시 타입(Primitive Types)

- `string`
    - 문자열
- `number`
    - 숫자
- `boolean`
    - true, false
- `undefined`
    - 값 할당 없는 변수의 기본 값
- `null`
    - ‘값 없음’을 할당
- `symbol`
    - 고유 식별자를 만들기 위한 타입
- `bigint`
    - 아주 큰 정수를 다루는 타입

### 객체 타입(Object Types)

- **객체(Object)**: key-value 쌍을 저장하는 컨테이너
    - `const user = { name: “chan”, age: 30 };`
- **배열(Array)**: 순서가 있는 리스트
    - `const pets = [”dog”, “cat”];`
- **함수(Function)**: 실행 가능한 객체
    - `function greet() { console.log(”Hello!”); }`
- 기타: Date, RegExp(정규표현식), Error, 사용자 정의 클래스 등

<br>

## 변수선언 (let, const)

변수 선언을 모던 자바스크립트에선 `const`, `let`으로 한다

var를 이용한 변수 선언의 문제

var로 선언하면 변수를 덮어쓸 수 있다는 점, 재선언 할 수 있다는 점 때문에 이용하지 않는다.

추가로 var로 선언한 변수는 자바스크립트가 undefined로 초기화 하는데 let, const는 초기화x

`var`: 재할당, 재선언 ⭕

`let`: 재할당 ⭕, 재선언 ❌

`const`: 재할당 ❌, 재선언 ❌ 

```jsx
// var, let, const의 차이 확인하기

// var는 재할당, 재선언 가능
var strVar = 'var';
console.log("var 최초 선언: "+ strVar);
>>> 최초 선언: var
strVar = 'var2';
console.log("var 재할당: "+ strVar);
>>> 재할당: var2
var strVar = 'var3';
console.log("var 재선언: "+ strVar);
>>> 재선언: var3

// let은 재할당 가능, 재선언 불가
let strLet = 'let';
console.log("let 최초 선언: " + strLet);
>>> 최초 선언: let
strLet = 'let2';
console.log("let 재할당: " + strLet);
>>> 재할당: let2
let strLet = 'let3'; // -> 재선언 시 오류발생
>>> SyntaxError: Identifier 'strLet' has already been declared

// const는 재할당, 재선언 불가
const strConst = 'const';
console.log("const 최초 선언: " + strConst);
>>> 최초 선언: const
strConst = 'const2'; // -> 재할당 시 오류 발생
>>> TypeError: Assignment to constant variable.
const strConst = 'const3'; // -> 재선언 시 오류 발생
>>> SyntaxError: Identifier 'strConst' has already been declared
```

### const로 정의한 변수를 변경할 수 있는 경우

재할당, 재정의가 모두 불가능한 상수를 표시하는 const지만 변수 종류에 따라 const로 정의해도 변수 값을 변경할 수 있는 경우가 있다

문자열이나 수치 등 원시타입은 const를 이용해 덮어쓸 수 없다.

객체나 배열 등 `object Type` 종류의 데이터는 const로 정의해도 값 변경이 가능하다.

리액트에서는 `const`를 많이 사용하고, 처리 도중에 값을 덮어 써야하는 변수만 let으로 선언

데이터가 객체나 배열로 넘어가는 경우가 많기 때문에 어차피 바꿀 수 있다.

<br>

## 블록 유효 범위(Block scope)

블록 스코프를 갖는 변수는 중괄호`{ }` 안에서만 유효

### let

블록 유효 범위를 갖는 지역 번수를 선언한다.

`let`으로 선언한 변수는 유효 범위가 블록 내부까지이다.

### const

블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수(상수)를 선언한다.

반드시 초기화 해야 한다.

`const`로 선언한 상수 값은 수정할 수 없지만 객체나 배열일 경우 수정가능

<br>

## 템플릿 리터럴(Template literal)

ECMA Script6 부터 추가된 문자열 표현 구문

표현식의 값을 문자열에 추가하거나 여러 줄의 문자열을 표현할 수 있음

### 기본 사용법

백틱 ``` 으로 문자열을 묶으면 하나의 템플릿으로 본다.

```jsx
// `이 없다면 줄바꿈을 이렇게 했을 경우 오류!
let txt = `I'm going to
javascript`;
```

### 보간 표현식

템플릿 리터럴 안에 플레이스홀더를 넣을 수 있다. `${ ... }` 로 표기

python f-string이랑 같은 느낌?

- 문자열 안에서 전개할 수 있고

- 자바스크립트 값도 다룰 수 있다. (함수, 연산 등)

```jsx
let num1 = 5, num2 = 10;
console.log(`${num1} + ${num2} = ${num1+num2}`);
>>> 5 + 10 = 15

// 문자열 안에서 변수 전개
const msg = `${num1} 더하기 ${num2} 는 ${num1+num2}`;
console.log(msg);
>>> 5 더하기 10 는 15

// 문자열 안에서 자바스크립트 값 다루기
function sayHello(){
    return "Hello!";
}
const message = `${sayHello()}!! everyone!`
console.log(message);
>>> Hello!!! everyone!
```

<br>

## 화살표 함수(Arrow function)

[MDN Web Docs - **Arrow function expressions**](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

ES2015에서 추가된 새로운 함수 표기법

- function 선언 없이 `( )` 안에 인수를 입력하고 `=>` 기호로 함수 작성

- 인수가 **한 개**인 경우는 소괄호 생략 가능, 인수가 **두 개 이상**일 땐 생략 불가

- 처리를 **한 행으로 리턴**하는 경우 중괄호와 return 생략 가능

- 반환값이 여러 행일 경우 ()로 감싼 뒤 단일 행과 같이 모아서 반환가능

```jsx
// 화살표 함수
const func = (value) => {
    return value;
}
console.log(func("arrow function!"));
>>> arrow function!

// 인수가 한 개일 땐 소괄호 생략 가능
const func2 = value => {
    return value;
}
console.log(func2("arrow function with 1 parameter"));
>>> arrow function with 1 parameter

// 처리를 한 행으로 리턴하는 경우 중괄호, 리턴 생략 가능
const func3 = (num1, num2) => num1 + num2;
console.log(func3(10, 20));
>>> 30

// 일반적인 함수에서 리턴이 없을 때 어떻게 되나?
const funcNoReturn = (num1, num2) => {
    num1 + num2;
}
console.log(funcNoReturn(10, 20));
>>> undefined

// 반환값이 여러 행일 경우
const func4 = (val1, val2) => (
    {
        name: val1,
        age: val2,
    }
)
console.log(func4("user", 30));
>>> { name: 'user', age: 30 }
```

<br>

## 분할 대입(Destructuring assignment)

[MDN Web Docs - **Destructuring**](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring)

객체, 배열로부터 속성을 해체하여 개별 변수에 할당하는 표현식

### 객체 분할 대입

- `{ }`를 변수 선언부에서 사용해 객체 안에 일치하는 속성 추출 가능
일부만 추출하거나 ,순서 추출 가능하지만 없는 속성 지정은 불가능

- 변수를 나열하는 순서가 상관없음(같은 값을 찾아서 알아서 할당)

- 추출한 속성에 별칭을 지정해 새로운 변수 이름으로 할당

```jsx
// 객체 생성
const userProfile = {
    name: 'user',
    age: '30',
};
const { name, age } = userProfile;

// 객체 분할 대입
const message = `내 이름은 ${name}입니다. 나이는 ${age}세 입니다.`;
console.log(message);
>>> 내 이름은 user입니다. 나이는 30세 입니다.

// 새로운 변수 이름 지정
const { name: userName, age: userAge } = userProfile;
const message2 = `내 이름은 ${userName}입니다. 나이는 ${userAge}세 입니다.`;
console.log(message2);
>>> 내 이름은 user입니다. 나이는 30세 입니다.
```

### 배열 분할 대입

배열에도 분할 대입이 가능

- 배열 인덱스를 지정해 대입 → 기존 방법

- `[ ]` 를 사용해 배열에 저장된 순서에 임의 변수 지정 가능

- 배열의 경우에는 배열에 들어있는 인덱스 순서를 지켜야 함

```jsx
// 배열 분할
const myArray = ['Welcome', 2026];

const [greeting, year] = myArray;
const arrayMsg = `${greeting} ${year}!`;
console.log(arrayMsg);
>>> Welcome 2026!
```

<br>

## 디폴트값(Default parameters)

[MDN Web Docs - **Default parameters**](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/Default_parameters)

함수의 매개변수는 `undefined`가 기본인데 이를 다른 값으로 설정해줄 수 있다.

함수의 인수나 객체를 분할 대입할 경우 설정해 사용

### 함수 매개변수가 존재하지 않을 때 초기값

매개변수 `name`에 들어와야 할 값이 없이 작동한 sayHello()함수는 `undefined`를 반환한다.

함수에 기본값을 설정해두고 인수 없이 `sayDefaultHello()`만을 하니 미리 지정해둔 초기값 'chan'으로 초기화되어 반환된다.

```jsx
const sayHello = name => {
    console.log(`Hello, ${name}!`);
};
sayHello();
>>> Hello, undefined!

// name 매개변수에 기본 값 지정
const sayDefaultHello = (name = 'chan') => {
    console.log(`Hello, ${name}!`);
};
sayDefaultHello();
>>> Hello, chan!
```

### 객체 분할 대입의 디폴트값

객체에서 해체된 값이 `undefined`인 경우, 변수에 기본값을 할당할 수 있다.

```jsx
// 객체 분할 대입의 디폴트값
const greeting = {
    hi: 'hello',
};

// 객체내부에 world가 존재하지 않지만 설정해줌
const { world = 'world', hi } = greeting;
const message = `${hi}, ${world}!`;
console.log(message);
>>> hello, world!
```

