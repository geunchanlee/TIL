# TIL_26/02/04 ~ 05 - Java 2

자바 시작 ~ 반복문까지 지난시간에 배웠다. 

[Java 1](./TIL_260203.md)

## 반복문

### 무한반복

```java
    while (true) {
         stmt; 
    }

    for ( ;; ) {
        stmt;
    }
```

이 반복문들은 종료지점이 없기 때문에 무한히 반복을 수행한다.
필요에 의해 무한반복을 사용할 경우 반드시 종료지점을 존재시켜야 한다.

### continue, break

`continue;` -> 이번 반복을 넘어간다.

`break;` -> 반복에서 벗어난다.

<br/>

## 데이터 타입

자바의 데이터타입은 기본타입(원시타입, primitive type)과 참조 타입(reference type)으로 분류한다.

**기본타입**을 이용해 선언한 변수는 실제 값을 변수 안에 저장하고, **참조타입**(배열, 열거, 클래스, 인터페이스)을 이용해 선언된 변수는 메모리 주소를 값으로 갖는다.

### 메모리 영역

### String 타입

문자열 리터럴(`””`)이 같다면 String 객체를 공유한다.

- 문자열 내용이 같다면 같은 주소를 가리킨다는 뜻
- `new` 연산자를 사용해 String 객체를 사용하면 같은 내용이더라도 새로운 객체를 생성한다.(다른 주소에 저장)

문자열 리터럴로 객체 생성하는 것과 `new` 연산자로 객체를 생성하는 것은 비교 연산 결과에서 차이가 생긴다.

`==` , `equals()` 

`string` 타입은 불변(immutable) 자료형이다.

- 한 번 할당된 공간이 변하지 않는다.
- 문자열을 바꾸게 되면 메모리의 새로운 영역에 값을 담고 새로 참조한다.

왜 불변 자료형일까?

**캐싱**: 다시 사용하거나 캐싱에 이용해 힙 공간 절약

**보안**: 외부 공격으로 값이 변경되는 것 막을 수 있음

**동기화**: 동시 실행되는 여러 스레드에서 안정적인 공유 가능

`StringBuffer`, `StringBuilder`

알고리즘에서 많이 사용

**StringBuffer**

String과 달리 문자열 수정 가능함

`append()` 메소드 이용해서 기존 문자열 수정 가능하다.

**StringBuilder**

StringBuffer와 달리 멀티스레드 동기화 기능이 제공되지 않아 해당 환경에서 사용시 좋음

문자열 파싱 성능이 우수함

이 둘은 가변(mutable)이다.

내부 버퍼에 문자열을 저장해두고 그 안에서 추가, 수정, 삭제 작업할 수 있다.

String은 불변이어서 값 업데이트 시 매 연산마다 새 문자열이 들어있는 String 인스턴스가 생겨 메모리 공간을 차지한다. StringBuffer, StringBuilder는 가변이어서 동일 객체 안에서 문자열 크기를 변경하기 때문에 변경시마다 객체를 새로 만드는 String보다 훨씬 빠르다. 문자열 추가, 수정, 삭제가 빈번하게 발생하는 경우라면 이 쪽을 사용하는게 좋다.

python으로 알고리즘 해결 할 때 sys.stdin.readline() 으로 입력 받던 것과 같은 이치


## Array

배열 변수 

배열 값을 0부터 시작해 선언한 숫자만큼 할당.

기본적으로 0으로 초기화한다.

한 번 만들어진 배열의 크기는 변경할 수 없다.

### 배열선언

```java
// 1. 정수형 배열 선언
int[] array1 = new int[5]; 

// 2. 선언 후 개별적으로 초기화
int[] num = new int[3];
num[0] = 1;
num[1] = 10;
num[2] = 100;

// 3. 선언과 동시에 초기화
int[] num = {1, 2, 3, 4, 5};
int[] num = new int[]{1, 2, 3, 4, 5};
```

1번 방법 처럼 크기만 지정해서 선언한다면 기본값으로 초기화된다.

- int: 0
- double: 0.0
- boolean: false
- String, 객체: null

**배열 탐색**은 반복문으로 가능하다

array.length를 사용해서 배열의 길이만큼 반복하면서 탐색하면 된다.

```java
int[] num = {1, 2, 3};

for (int i = 0; i < num.length; i++) {
    System.out.println(num[i]);
}

>>> 1
>>> 2
>>> 3
```


### for-each문

기존에 배운 반복문을 사용해서도 배열 원소에 순차적 접근이 가능하지만 더 편하게 가능한 방법이 있다.

for-each 구문이 있진 않고 for문의 조건식이 바뀐다

```java
    for ( 변수 : 배열레퍼런스 ) {
        stmt;
    }
```

방금 위에서 본 반복문을 for-each로 바꾸면 다음과 같다.

```java
int[] num = {1, 2, 3};

for (int i : num) {
    System.out.println(i);
}

>>> 1
>>> 2
>>> 3
```


### **Array 복사하기**

반복문을 이용해 각 요소 값을 복사하거나 `System.arraycopy()`메소드를 이용해 복사한다.

`System.arraycopy(src, srcPos, dest, destPos, length)` 

- `src` 복사할 배열 이름
- `srcPos` 복사할 배열의 첫 번째 위치
- `dest` 복사해서 붙여 넣을 대상 배열의 이름
- `destPos` 복사해서 대상 배열에 붙여넣기 시작할 첫 번째 위치
- `length` src에서 dest로 자료 복사할 요소 개수

dest 배열 기존 요소에 덮어쓴다.

**deep copy, shallow copy**

- 주말에 추가 공부하기

### 다차원 배열

배열을 이용해 2차원 배열을 만들 수 있다.

```java
int [][] arr1 = new int [2][3];
int [][] arr2 = {{1,2,3},{4,5,6}}
```

<br/>

## ArrayList

배열은 한 번 정의하면 크기를 수정할 수 없다는 불편함이 존재한다.

배열의 크기를 원하는대로 추가/삭제 할 수 있도록 지원하는 컬렉션 클래스 ArrayList를 사용한다.

`import java.util.ArrayList`

`add()`, `get()`, `set()`, `size()`, `remove()`같은 메소드를 사용해 리스트 원소들을 관리한다.

```java
ArrayList<Integer> num = new ArrayList<Integer>();

num.add(1);
num.add(10);

// get(index), set(index)
int getNum = num.get(0); // getNum = 1
num.set(0,100); // 인덱스 0의 1이 100으로 바뀜

// size()
num.size() // 리스트의 개수 확인

// remove()
num.remove(1); // 1번 인덱스의 값 삭제
num.clear(); // 전부 제거
```

ArrayList의 원소들은 객체이다. String같은 클래스로 만들어진 객체는 사용할 수 있지만, int나 long, double같은 원시타입(Primitive Type)은 사용할 수 없다. 

예시에서 `<Integer>`처럼 원시 데이터 타입을 객체로 사용하게 해주는 Wrapper Class를 사용해야 한다.  

Wrapper < Byte, Short, Integer, Long, Character, Float, Boolean > 8가지 기본 타입을 객체로 다룰 수 있다.

### Map

key-value 쌍으로 데이터를 저장하는 컬렉션

배열의 인덱스를 숫자를 포함한 모든 타입으로 지정 가능하다.

key는 중복되지 않는다.

```java
Map<Key, Value> ref = new HashMap<Key, Value>();
```