# TIL_26/02/09 - Java Inheritance

자바 클래스에 이어 상속 학습

## 상속(*Inheritance*)


중복되는 기능을 상속해서 사용한다. `extends` 키워드로 사용

상위 클래스의 **멤버변수, 메소드** 모든 것을 하위 클래스가 상속받는다.

다이어그램으로 하위 클래스(상속받는 클래스)에서 상위 클래스로 화살표가 이어지게 표현한다.

**상위 ← 하위**

`private` 변수는 하위클래스에서 상속이 불가능하다. 대신에 **`protected`**를 사용하면 상속받을 수 있다.

### super

super 예약어는 하위 클래스에서 상위 클래스에 접근할 때 사용한다.

super()메소드가 상위클래스에서 모든것을 받아오도록 해주는 메소드임

상위클래스의 생성자를 호출하는데도 사용한다.

- 작성하지 않아도 묵시적으로 호출함
- 부모클래스는 자식클래스의 존재를 알 수 없다.

> **주의할 점**

기본 생성자에 매개변수가 정의되어 있고 매개변수 없는 디폴트 명시자가 정의되지 않았다면 super()메소드로 상위 클래스를 호출할 때 매개변수를 넘겨줘야 한다.

<br/>

## 메소드 오버라이딩(_method overriding_)

**메소드 오버로드**, **메소드 오버라이딩**은 꼭 외우자!

**method overriding**

- 상위클래스에서 정의한 메소드가 하위 클래스에서 구현할 내용과 맞지 않을 때 하위클래스에서 메소드를 재정의하는 것

**반환형, 메소드 이름, 매개변수 개수, 자료형**이 같아야 함

메소드 오버로딩 → 매개변수 타입, 개수가 다른 같은 이름의 메소드 만들기

메소드 오버라이딩 → 하위클래스에서 상위클래스의 메소드 재정의해서 사용하기

<br>

## 다형성(_polymorphism_)

상위클래스에서 공통 메소드를 제공하고 하위클래스가 이를 상속한 경우

이를 상속받은 하위클래스는 하위클래스 타입을 가질 수 있지만 상위 클래스 타입을 가질 수도 있다.

상위

### 상속관계

1. **IS-A 관계(is a relationship; *inheritance*)**
    - 일반적인 개념 - 구체적인 개념 관계
    - ex) 사람은 표유류이다
    - 일반 클래스를 점차 구체화하는 상황에서 상속을 사용하는 것
    - 단순 코드 재사용 목적으로 관련없는 개념 클래스들을 상속관계로 사용하지 말자
2. **HAS-A 관계(has a realationship; *association*)**
    - 한 클래스가 다른 클래스를 소유한 관계
    - ex) 학생 - 수강과목
    - 과목은 학생에 포함되어 멤버변수로 사용하는게 적절함

상속을 사용하면 클래스 결합도가 높아져 상위 클래스 변화가 하위 클래스에 영향을 미치게 된다.

상속을 단순한 코드 재사용의 개념으로 사용하지 말고 **“일반적 클래스” - “구체적 클래스”**의 관계로 구현해야 한다.

<br/>

## 추상 클래스(_abstract class_)

지금까지는 클래스, 메소드를 만들면 내용을 전부 구현했다.

메소드의 구현부가 생략되면 추상 메소드라고 한다.

- 메소드의 이름만 선언하고 구현 내용이 없는 것
- 구현은 상속받은 하위클래스 너가 해!

**`abstract`** 키워드로 선언만 하는 메소드이고 추상 클래스는 추상 메소드를 포함한다.

_이탤릭채로_ 기울여둔게 _**추상메소드**_ 표현

추상클래스를 상속받은 하위클래스에서는 추상 메소드를 꼭 구현해야 한다.

하위 클래스마다 다르게 구현할 메소드는 추상 메소드로 선언해두고 사용한다.

추상클래스는 인스턴스(객체)화 할 수 **없다!**

**추상클래스1 - 추상클래스2 - 클래스3의 예시**

1. 추상클래스 1에서 3개의 추상 메소드를 선언
2. 추상클래스 2에서 추상메소드 3개 중 2개 오버라이딩
3. 클래스3번에서 나머지까지 다 구현하면 인스턴스 생성 가능!

```java
// 추상 클래스 1
public abstract class AbstractClass1 {
	
	public abstract void method1();
}
```

<br/>

## 템플릿 메소드(_template method_)

메소드의 실행 순서와 시나리오를 정의하는 것

템플릿 메소드는 재정의할 수 없게 `final` 키워드를 사용한다.

### final

상수

다른 값을 대입할 수 없다.

클래스를 final로 선언하면 상속할 수 없다.

- 상속하면 재정의가 가능한데 원래 기능에 오류 생길 수 있기 때문
- 정말 필요한 경우가 아니라면 final로 클래스를 선언하지 않음

**실습 예제: 추상 클래스 `PlayerLevel`**

4개의 추상 메소드와 템플릿 메소드 go를 볼 수 있다.

```java
public abstract class PlayerLevel {  
    // 추상 메소드 run, jump, turn, showLevelMessage 선언  
    public abstract void run();  
  
    public abstract void jump();  
  
    public abstract void turn();  
  
    public abstract void showLevelMessage();  
  
    // 템플릿 메소드 go  
    final public void go(int count) {  
        run();  
        for (int i = 0; i < count; i++) jump();  
        turn();  
    }  
}
```