# TIL 26/01/20 - React 1

[React 2](./TIL_260121.md)


## React

웹사이트를 구축할 때 사용하는 자바스크립트 UI 라이브러리(프레임워크 x)

**SPA**를 쉽고 빠르게 만들 수 있는 도구

### React 특징

**Virtural DOM**을 사용한다

- 업데이트할 최소한의 부분만을 찾아서 업데이트. 상태 변경이 일어나면 업데이트할 최소한의 부분을 검색해 해당 부분만 업데이트하고 다시 렌더링한다.

**컴포넌트 기반 구조**

- 리액트는 모든 페이지가 **컴포넌트**로 구성되어 있고, 하나의 컴포넌트는 또 다른 여러 개의 컴포넌트 조합으로 구성될 수 있다.
- 컴포넌트를 항상 쉽고, **재사용 가능한 형태**로 개발해야 한다.

**React Native를 추가로 학습해 모바일 앱 개발 가능**

**기타**

- 프론트엔드 화면만 신경쓰는 라이브러리다. → 기타 기능은 모두 직접 구현해야 한다.
- 기타 기능은 외부 라이브러리를 사용해야 한다
- 다른 프레임워크, 라이브러리와 혼용할 수 있다.

### 설치

node.js 설치

npm 설치

vscode 확장 설치

- reactjs code snippets, eslint, prettier

### 시작해보기

terminal에서 `npx create-react-app myapp`

실행 후 public 폴더에 `index.html`을 보면 root라는 div가 정의되어 있고

src/index.js에 root에 렌더링할 내용이 있다.

`npm start` 명령어를 실행하면 화면이 표시된다.

<br/>

## JSX: *Javascript Syntax Extension*

**자바스크립트 확장 문법**

자바스크립트와 XML / HTML을 합친 것이다

`const element = <h1>Hello, world!</h1>`

JSX는 내부적으로 XML / HTML코드를 자바스크립트로 변환하는 과정을 거치게 된다.

JSX로 코드를 작성하면 최종적으로는 자바스크립트 코드가 출력된다.

`createElement()` 함수 → JSX코드를 자바스크립트 코드로 변환한다.

가독성, 보안성의 향상을 이룬다

### JSX 실습

*src/ex01/Book.jsx*

```jsx
import React from "react";

function Book(props) {
    return (
        <div>
            <h1>{`이 책의 이름은 ${props.name}입니다.`}</h1>
            <h2>{`이 책은 총 ${props.numOfPage}페이지로 이루어져 있습니다.`}</h2>
        </div>
    )
}

export default Book;
```

`Book` 컴포넌트를 작성한다.

`rsf` 작성하고 탭 하면 기본 틀이 자동 완성됨(코드스니펫 기능)

props의 `name`과 `numOfPage`를 가져와 사용한다.

```jsx
import React from 'react';
import Book from './Book';

function Library(props) {
    return (
        <div>
            <Book name="코딩 좀 아는 사람" numOfPage={312} />
            <Book name="Java 언어로 배우는 디자인 패턴 입문" numOfPage={560} />
            <Book name="가즈아" numOfPage={284} />
        </div>
    );
}

export default Library;
```
*src/ex01/Library.jsx*

Book 컴포넌트를 사용하는 Library 컴포넌트

*src/index.js*에서 만든 컴포넌트를 렌더링하도록 하면 표시할 수 있다.

```jsx
import Library from './ex01/Library';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Library /> 
  </React.StrictMode>
);

```

`root.render` : 컴포넌트를 페이지에 렌더링하는 역할 react-dom 모듈에서 사용가능

첫 번째 파라미터에는 페이지에 렌더링할 내용을 JSX형태로 작성, 두 번째 파라미터에는 JSX 렌더링할 document 내부 요소 설정

`<Library>`를 import한 뒤 화면에 렌더링하는 코드이다.

### Clock

```jsx
import React from 'react';

function Clock(props) {
    return (
        <div>
            <h1>Hello, React!</h1>
            <h2>TIME: {new Date().toLocaleTimeString()}</h2>
        </div>
    );
}

export default Clock;
```

페이지를 렌더링할 때의 시간을 찍어주는 Clock컴포넌트

시간을 업데이트하려면 어떻게 할까?

`index.js` 파일

```jsx
const root = ReactDOM.createRoot(document.getElementById('root'));
setInterval(() => {
    root.render(
        <React.StrictMode>
            <Clock />
        </React.StrictMode>,
    );
}, 1000);
```

`root.render`를 `setInterval`을 이용해 1초마다 다시 렌더링시킨다.

시계가 1초씩 올라가는데 전체 페이지를 새로고치는것이 아니라 DOM만 1초에 한 번씩 다시 렌더링하는 것임

<br/>

## 컴포넌트

**컴포넌트 이해하기**

공통으로 사용할 수 있는 영역을 독립적으로 구분시킨다.

- 템플릿 이상의 역할을 한다

- 데이터가 주어졌을 때 이에 맞추어 UI를 만들어 낸다

- 라이프사이클 API를 이용해 컴포넌트가 화면에 나타날 때, 사라질 때, 변화 일어날 때 주어진 작업 처리 가능하다

- 임의의 메소드를 만들어 특별한 기능 붙여줄 수 있다

**리액트 컴포넌트**: 어떤 속성들을 입력으로 받아 그에 맞는 리액트 엘리먼트를 생성해 리턴해주는 것

만들고자 하는대로 **props**를 넣으면 해당 속성에 맞춰 화면에 나타날 엘리먼트를 만들어주게 된다.

### props

컴포넌트에 전달할 다양한 정보를 담고 있는 자바스크립트 객체

- props값은 리액트 컴포넌트가 엘리먼트 생성을 위해 사용하는 값

- 읽기 전용이다

- 다른 props의 값으로 엘리먼트를 생성하려면 새로운 값을 컴포넌트에 전달해 새로 엘리먼트를 생성해야 한다.

- 리액트 컴포넌트의 props는 바꿀 수 없고, 같은 props가 들어오면 항상 같은 엘리먼트를 리턴해야 한다.

App 컴포넌트에 props값 설정

props값 들어가는 부분에 `{}` 사용하면 다양한 타입 변수를 비롯해 컴포넌트도 넣기 가능

컴포넌트에 값 전달 시 `{}`를 쓰지 않으면 문자열로 묶어서 전달되기 때문에 `{}` 사용해야 함

### props 초기값 설정

자바스크립트 문법으로 대체

함수 파라미터 기본값 설정을 사용하면 된다.

**React 문서**에 나온 내용

값이 지정되지 않았을 때, prop에 기본값을 주길 원한다면, 변수 바로 뒤에 `=` 과 함께 기본값을 넣어 구조 분해 할당을 해줄 수 있습니다.

`function Avatar({ person, size = 100 }) {  // ...}`

```jsx
function Book({name = '초기값', numOfPage}) {
    return (
        <div>
            <h1>{`이 책의 이름은 ${name}입니다.`}</h1>
            <h2>{`이 책은 총 ${numOfPage}페이지로 이루어져 있습니다.`}</h2>
        </div>
    );
}
```

React문서를 보고 { }로 구조 분해 할당 해서 props를 불러온다. 

일반적으로 props를 통채로 사용하지 않고 사용할 요소만 명시해서 쓴다고 한다.

name에 초기값을 지정하니 Library컴포넌트에서 Book을 불러와 사용할 때 name을 지정하지 않은 요소에 초기값이 표시된다.

### children

컴포넌트 태그 사이의 내용을 보여주는 props

`{props.children}` 을 컴포넌트에 넣어두면 태그 사이에 쓴 값이 들어가게 됨.

`<component>children</component>` 여기선 children이 component 컴포넌트의 children자리에 들어감

### 클래스형 컴포넌트

클래스형 컴포넌트는 함수형과 다르게 state기능, 라이프사이클 기능을 사용할 수 있고, 임의 메소드를 정의할 수 있다.

클래스형 컴포넌트에는 render 함수가 꼭 있어야 하고, 보여 주어야 할 JSX를 반환해야 함

### 함수형 컴포넌트

**장점**

- 클래스형 컴포넌트보다 선언하기 편하다

- 메모리를 클래스형 컴포넌트보다 덜 사용한다

- 빌드 후 배포 시 결과물의 파일 사이즈가 더 작다

**단점**

- state, lifecicle api 사용이 불가능하다. (Hook 기능 도입으로 해결됨)

리액트 메뉴얼에서 컴포넌트를 새로 작성 시 함수형 컴포넌트와 Hooks 사용을 권장함

### 컴포넌트 이름

**컴포넌트 이름은 항상 대문자로 시작**

- 리액트에서 소문자로 시작하는 컴포넌트는 DOM 태그로 인식한다.
- `<div>`, `<span>` 같은 태그가 문자열 형태로 전달됨
- 첫 글자를 대문자로 해야 컴포넌트로 해석할 수 있음

### 컴포넌트 합성

여러 개의 컴포넌트를 합쳐 하나의 컴포넌트로 만들기

<br/>

## state

리액트 컴포넌트의 상태

컴포넌트 내부에서 바뀔 수 있는 값

- 사전에 정해진 게 아니라 리액트 컴포넌트 개발자가 정의해서 사용

- state를 정의할 때 렌더링

클래스 컴포넌트는 state를 생성자에서 정의, 함수형 컴포넌트는 `useState` 훅을 사용해 정의

- state는 임의로 바꿀 수 없고 `setState()` 함수를 사용해 변경한다


### 클래스형 컴포넌트에서 상태관리

→ `rcc` 로 클래스 컴포넌트 기본 틀 자동 생성

- 클래스 컴포넌트의 state 초기값은 객체 형태로 주어짐


```jsx
import React, { Component } from 'react';

class Counter extends Component {
    constructor(props) { // state를 정의하는 생성자
        super(props);
        this.state = { number: 0 };
    }
    render() {
        const { number } = this.state; // 객체분할대입으로 상태값을 받음
        return (
            <div>
                <h1>{number}</h1>
                <button
                    onClick={() => {
                        this.setState({ number: number + 1 });
                    }}
                > +1 </button>
            </div>
        );
    }
}

export default Counter;
```

클래스형 컴포넌트에서 state 설정 시 생성자로 정의하고 super(props)를 반드시 호출해야 함.

버튼 이벤트에 함수를 넣어줄 때는 화살표 함수를 사용함

### 함수형 컴포넌트는 useState사용

[React 참고서 - **useState**](https://ko.react.dev/reference/react/useState)

→ `rsc` : 빈 div를 가진 화살표 함수 컴포넌트 생성 

- `useState`에서는 초기값이 객체가 아니어도 됨. 값 형태는 숫자, 문자열, 객체, 배열 등 어떤 유형의 값이든 자유

- `useState` 함수를 호출시 두 개의 값을 가진 배열을 반환함

    - 첫 번째 원소는 state: 현재상태
    
    - 두 번째 원소는 setState: 상태 설정할 수 있는 setter이다

```jsx
import React, { useState } from 'react';

const Say = () => {
    const [message, setMessage] = useState('');
    const onClickEnter = () => setMessage('Hello!');
    const onClickLeave = () => setMessage('Bye!!');
    const [color, setColor] = useState('black');
    return (
        <div style={{ textAlign: 'center' }}>
            <button onClick={onClickEnter}>Enter</button>
            <button onClick={onClickLeave}>Leave</button>
            <h1 style={{ color }}>{message}</h1>
            <button style={{ color: 'red' }} onClick={() => setColor('red')}>
                RED
            </button>
            <button
                style={{ color: 'green' }}
                onClick={() => setColor('green')}
            >
                GREEN
            </button>
            <button style={{ color: 'blue' }} onClick={() => setColor('blue')}>
                BLUE
            </button>
        </div>
    );
};

export default Say;
```

message, color 상태는 배열로 주어진다. 첫 값은 현재 상태, 그 다음은 상태를 설정할 수 있는 setter이다. 배열 분할 대입으로 두 요소를 담는다.