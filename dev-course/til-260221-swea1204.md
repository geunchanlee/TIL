# TIL 26/02/21 - SWEA 1204. 최빈수 구하기

문제 링크: [최빈수 구하기 - D2](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV13zo1KAAACFAYh)

**문제**

- 첫 줄에 테스트 케이스 개수 T가 주어지고 그 다음 줄에 테스트 케이스의 번호가 주어진다.
- 최빈수를 테스크 케이스 번호와 함께 출력한다.
- 최빈수가 여러 개일 땐 가장 큰 수를 출력한다.
- 학생 수는 1000명이고 각 학생 점수는 0점 이상 100점 이하의 값이다.

**해결 방법**
1. `Dictionary`자료형으로 들어온 점수의 개수를 저장한다.
2. 배열을 순회하면서 점수를 `Dictionary`에 업데이트한다.
3. 전체 수에 대한 확인이 끝나면 `Dictionary`에서 `Value`가 가장 큰 `Key`를 찾아 출력한다.


> [!cite]- **input**
>	1
>	1  
>	41 85 72 38 80 69 65 68 96 22 49 67 51 61 63 87 66 24 80 83 71 60 64 52 90 60 49 31 23 99 94 11 25 24 51 15 13 39 67 97 19 76 12 33 99 18 92 35 74 0 95 71 39 33 39 32 37 45 57 71 95 5 71 24 86 8 51 54 74 24 75 70 33 63 29 99 58 94 52 13 35 99 46 57 71 23 17 3 94 48 77 18 83 11 83 25 59 62 2 78 86 7 94 65 80 32 39 84 60 65 72 61 58 84 8 72 12 19 47 49 49 59 71 52 34 22 21 20 92 33 80 39 74 9 28 97 100 93 29 25 4 66 79 81 98 21 91 62 82 4 59 100 34 1 51 80 92 69 77 39 38 97 51 34 35 19 22 1 67 9 90 31 82 11 51 84 78 70 74 42 100 88 53 80 57 62 32 51 48 63 92 46 4 61 31 98 69 52 88 20 68 41 48 79 97 98 56 44 73 3 63 100 87 87 41 79 64 83 63 1 21 72 24 9 75 51 25 53 77 0 52 30 96 93 32 89 70 89 55 71 79 40 10 64 80 30 19 62 67 98 42 8 32 57 27 22 1 38 89 52 74 43 8 2 65 82 20 67 22 43 22 95 16 48 25 6 75 86 96 3 85 43 69 93 4 61 53 81 43 84 20 15 34 22 35 26 28 33 67 19 79 19 45 8 13 51 0 86 68 18 47 82 3 16 80 0 18 39 22 5 26 65 70 21 92 66 65 14 6 46 46 21 32 80 35 86 6 67 29 42 71 14 77 55 3 1 14 38 71 82 41 65 12 5 77 3 67 22 59 40 81 48 63 63 25 45 32 78 83 26 96 18 99 45 56 31 30 45 47 80 1 7 81 18 1 90 15 71 22 69 44 18 31 60 16 93 13 17 44 97 98 51 46 42 22 47 72 97 24 52 55 59 25 100 28 5 14 76 32 41 97 61 32 20 0 2 8 41 52 77 35 22 98 78 92 68 29 82 33 28 16 5 9 21 13 26 39 59 69 10 42 4 13 80 34 42 100 44 32 70 15 32 8 83 10 23 73 8 53 7 21 10 52 14 82 28 24 33 94 59 4 17 73 53 85 31 100 74 74 12 72 38 34 14 22 53 0 30 95 3 52 79 41 36 81 25 24 67 48 95 44 7 96 77 90 48 92 45 78 93 95 38 71 4 83 79 64 89 0 76 81 34 66 1 13 58 4 40 5 24 17 6 65 13 13 76 3 20 8 36 12 60 37 42 53 87 10 65 42 25 47 41 33 71 69 94 24 12 92 11 71 3 82 91 90 20 95 44 76 60 34 95 49 40 89 4 45 27 9 34 82 59 2 20 68 22 29 10 1 23 19 47 16 76 47 49 90 94 10 18 55 69 14 26 59 77 73 8 21 72 1 74 76 51 94 44 24 98 71 77 59 9 12 49 38 72 22 55 35 61 16 48 41 21 67 74 92 4 7 85 34 92 39 96 42 26 1 1 4 64 33 96 62 23 67 76 26 47 32 73 82 30 14 61 21 92 40 4 2 38 76 64 8 14 3 49 71 31 38 86 98 17 15 98 32 55 69 46 61 3 44 67 50 44 76 0 45 23 25 11 82 99 11 39 50 40 21 52 17 60 44 90 44 6 16 38 3 41 43 56 26 24 0 9 90 36 50 13 42 88 87 66 32 28 73 94 52 11 35 47 9 87 37 57 15 56 38 95 6 43 23 30 84 39 88 69 5 34 81 93 86 2 77 10 28 30 97 68 14 12 88 1 100 35 73 30 2 43 11 41 58 82 6 84 71 16 18 67 41 100 92 78 57 7 35 69 56 76 13 93 26 26 38 21 96 7 88 2 60 17 54 95 26 2 0 21 87 11 96 36 83 88 31 24 24 62 14 88 84 39 22 17 84 96 1 78 91 53 9 35 75 87 100 33 80 42 7 20 50 65 81 92 14 45 96 34 6 20 86 51 4 19 70 91 13 0 42 70 43 15 47 14 96 72 41 91 11 72 7 92 12 16 51 13 86 40 50 43 55 26 7 1 70 18 71 99 49 55 94 78 40 59 20 96 34 6 28 85 42 70 62 63 32 34 97 80 49 47 50 73 85 63 20 29 0 19 91 84 58 55 33 4 68 55 12 38 49 9 13 99 4 35 26 5 42 29 98 20 95 77 36 63 41 42 45 81 40 53 60 5 55 9 13 34 6 52 28 35 33 29 21 67 57 61 21 41 95 54 50 19 81 75 67 73 77 47 40 83 16 28


### Python 코드

```python
T = int(input()) 

# 테스트 케이스 개수만큼 반복
for t in range(T): 
	tc_num = int(input()) # 테스트케이스 번호 입력받기
	arr = [int(i) for i in input().split()] # 점수 배열 입력받기
	scores = dict() # 점수 개수 저장할 딕셔너리 자료형 생성
	
	# 딕셔너리에 각 점수의 개수를 넣는 반복문
	for i in arr:
		if i in scores:
			scores[i] += 1
		else:
			scores[i] = 1
			
	# 최빈값 저장할 변수
	mode_key = 0
	mode_value = 0 
	
	# 최빈값을 찾는 반복문
	for k, v in scores.items():
		if v > mode_value:
			mode_value = v
			mode_key = k
		elif v == mode_value and k > mode_key:
			mode_value = v
			mode_key = k
	
	# 형식에 맞게 최빈값 출력
	print(f'#{tc_num} {mode_key}')

>>> #1 71
```

테스트 케이스의 개수, 테스트 케이스의 번호를 입력받는다. 그 다음 점수들을 입력받아 리스트로 만든다.
딕셔너리 자료형을 이용해 각 점수들이 몇 번 등장하는지 저장하기 위해 `scores`를 만든다.

반복문으로 미리 입력받은 점수 배열 arr에 들어있는 점수들을 딕셔너리에 입력한다.
리스트를 순회하면서 값이 이미 들어있는 `key`라면 `value`를 `+ 1`하고 들어있지 않은 경우 해당 `key`의 `value`를 `1`로 초기화하고 딕셔너리에 저장한다.

그 다음 최빈값을 찾을 때 사용할 변수 `mode_key`, `mode_value`를 선언한다. ( Mode == 최빈값 ) 
`mode_key`는 최빈값, `mode_value`는 최빈값이 등장한 횟수이다.

반복문으로 딕셔너리 `scores.items()`를 순회하면서 키, 값을 `k, v`쌍으로 가져온다.

1. ***if*** 가져온 값 `v`가 `mode_value`보다 큰 경우:
	- 이 경우는 해당 점수가 기존 최빈값보다 더 많이 리스트에 나타난 것이다.
	- 최빈값, 최빈값 등장 횟수를 업데이트한다.
2. ***elif***  가져온 값 `v`가 `mode_value`와 같고, `k`가 `mode_key`보다 큰 경우:
	- 문제에서 최빈수가 여러 개인 경우 더 큰 수를 출력하라고 한 조건을 충족하기 위한 분기이다.
	- 최빈수가 같을 때 최빈값이 더 큰 쪽으로 업데이트한다.

딕셔너리에서 제일 큰 값을 찾기 위해 반복문을 사용했다. 문제의 조건이 아니라면 `max()`, `values()`함수를 통해 딕셔너리 값 중 제일 큰 값을 쉽게 찾을 수도 있다.

```Python
d = {10:4, 11:3, 12:2, 13:1}

dict_values = d.values() # dictionary.values() 메서드 사용
print(dict_values)
>>> dict_values([4, 3, 2, 1]) # dictionary.values() 반환값

print(max(dict_values)) # max()를 이용해 value들 중 가장 큰 값 찾기
>>> 4

# 제일 큰 value의 key 얻기
max_key = max(d, key=d.get)
print(max_key)
>>> 10
```

딕셔너리 메소드인 `dictionary.values()`를 사용하면 딕셔너리의 모든 값을 dict_values객체로 반환한다.
반환받은 객체에 `max()`함수를 이용하면 해당 딕셔너리에서 가장 큰 값이 뭔지 알 수 있다. 

더 나아가 `max()`함수의 `key=func`를 이용해 가장 큰 값을 갖는 키도 찾을 수 있다.
그냥 `max(d)`를 한다면 딕셔너리 d의 `key`중 가장 큰 `13`을 반환하지만, `max()`가 작동할 방식을 알려주는 `key=`에 `d.get`을 전달하면, 딕셔너리의 `value`들을 비교하여 가장 큰 `value(4)`를 가진 `key(10)`를 반환한다.

---

### Java 코드

```java
import java.util.HashMap;  
import java.util.Iterator;  
import java.util.Scanner;  
import java.io.FileInputStream;  
  
public class Solution {  
    public static void main(String[] args) throws Exception {  
        System.setIn(new FileInputStream("res/input.txt"));  
        Scanner sc = new Scanner(System.in);  
        int T;  
        T = sc.nextInt();  
        // 테스트 케이스 개수만큼 반복  
        for (int t = 0; t < T; t++) {  
            int tcNum = sc.nextInt();  
            // 점수들 저장할 배열 만들고 입력받기  
            int[] arr = new int[1000];  
            for (int i = 0; i < 1000; i++) {  
                arr[i] = sc.nextInt();  
            }  
            // HashMap 자료구조로 점수, 개수를 쌍으로 저장하기  
            HashMap<Integer, Integer> scores = new HashMap<>();  
            // 배열 순회하면서 점수가 해시맵에 있으면 값 증가시키고
            // 없다면 해시맵에 새로 추가  
            for (int i : arr) {  
                if (scores.containsKey(i)) {  
                    scores.put(i, scores.get(i) + 1);  
                } else {  
                    scores.put(i, 1);  
                }  
            }  
            
            int mode_key = 0;  
            int mode_value = 0;  
            
            // 이터레이터로 해시맵 순회하면서 최빈수 찾기  
            // 기존 최빈보다 더 많이 등장한 수는 바로 업데이트한다  
            // 기존 최빈수보다 등장 횟수가 많으면서 key(점수)도 큰 경우에도 업데이트한다  
            Iterator<Integer> keys = scores.keySet().iterator();  
            while (keys.hasNext()) {  
                int key = keys.next();  
                if (scores.get(key) > mode_value) {  
                    mode_key = key;  
                    mode_value = scores.get(key);  
                } else if (scores.get(key) == mode_value && key > mode_key) {  
                    mode_key = key;  
                    mode_value = scores.get(key);  
                }  
            }  
            
            System.out.print("#" + tcNum + " ");  
            System.out.println(mode_key);  
        }  
    }  
}
```

> [!tldr] 출력 결과

```text
#1 71
```

위의 파이썬 코드를 자바로 옮겼다.
점수 저장할 배열을 만들 때 주어진 점수의 개수인 1000개로 만들어 사용했다.
python의 dictionary사용 부분을 `HashMap`을 이용해 구현했다. 
`for-each`로 python과 유사하게 해시맵에 점수-등장횟수를 넣어준다.

그 다음 iterator를 사용해 HashMap을 순회하면서 위의 코드와 유사한 기능을 작성했다.
이번에 사용한 해시맵 메서드
- `HashMap.get('key')`: 'key'로 값을 가져온다.
- `HashMap.keySet()` : `map`에 있는 모든 `key`의 집합(`Set`)을 반환한다.

---

### 참고한 글

- [Python Dictionary values() Method, W3Schools](https://www.w3schools.com/python/ref_dictionary_values.asp)
- [python max function using 'key' and lambda expression, Stack Overflow](https://stackoverflow.com/questions/18296755/python-max-function-using-key-and-lambda-expression)
- [Java Iterator, W3Schools](https://www.w3schools.com/java/java_iterator.asp)
- [Java HashMap keySet() Method, W3Schools](https://www.w3schools.com/java/ref_hashmap_keyset.asp)
- [LasBe, "[Java/자바] 해시맵, HashMap 사용법과 EntrySet, Iterator", Tistory](https://lasbe.tistory.com/63)